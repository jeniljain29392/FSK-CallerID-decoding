/**@file fskmodem.c
 *	
 * @author Jenil Jain
 * This project is released under the GNU Public License.
 *
 * @brief FSK Demodulation
 *
 * Demodulate the CallerID FSK data by using various filter based on
 * the FSK frequencies. 
 *	
 * @note Includes code and algorithms from the Zapata library and Aesterisk.
 */
#include <stdint.h>
#include <unistd.h>

#include "filter_coefficients.h"
#include "fskmodem.h"
#include "gnuplot/gnuplot_i.h"

#define SCALE                           25000000	// Scaling factor

#define STATE_SEARCH_STARTBIT	        0
#define STATE_SEARCH_STARTBIT2	        1
#define STATE_CHANNEL_SEIZURE	        2
#define STATE_MARK_SIGNAL               3
#define STATE_GET_DATA_FRAME            4

static int count = 0;   // Count for Channel Seizure and Mark Signal bits

#ifdef DEBUG

#define PLOT_NUM 						800
double sample_value[PLOT_NUM];
double mark[PLOT_NUM], space[PLOT_NUM];
double diff[PLOT_NUM];
double lp[PLOT_NUM];
int gnu = 0;
int gnu_count = 0;
#endif

/**@brief Get the current sample.
 *	
 * Get the value of the current sample and increment the pointer.
 * Also decrement the length.	
 *
 * @param buffer Address of pointer of current sample
 * @param len Address of the length variable
 * @return current sample value
 */
static int iget_sample(short **buffer, int *len)
{
    int retval;
    retval = (int) **buffer;
    (*buffer)++;
    (*len)--;
    return retval;
}

/**@brief General function for filtering any frequency.
 *
 * All the filters used are IIR Butterworth filter and the general equation for it, is
 *
 * y[n] = c0*x[n] + c1*x[n-1] + ... + cM*x[n-M] - ( d1*y[n-1] + d2*y[n-2] + ... + dN*y[n-N]) 	<BR>
 * where N = no. of previous outputs &                                                          <BR>
 *      M = no. of previous inputs                                                              <BR>
 *      c1,c2,...,cM = input coefficients                                                       <BR>
 *      d1,d2,...,dN = output coefficients                                                      <BR>
 *      x[n] = input values                                                                     <BR>
 *      y[n] = output values                                                                    <BR>
 *
 * The c_coef, d_coef and the gain depends on the order and type of the filter 				
 * 
 * @param fs structer containing all the filter parameter for a particular frequency 			
 * @param in current input value
 *
 * @return current output value
 */
static int filter(struct filter_struct *fs, int in)
{

    fs->xv[0] = fs->xv[1];      // Shifting previous input values
    fs->xv[1] = fs->xv[2];
    fs->xv[2] = fs->xv[3];
    fs->xv[3] = fs->xv[4];
    fs->xv[4] = fs->xv[5];
    fs->xv[5] = fs->xv[6];

    fs->xv[6] = in / fs->gain;  // Calculting current input value

    fs->yv[0] = fs->yv[1];      // Shifting previous output values
    fs->yv[1] = fs->yv[2];
    fs->yv[2] = fs->yv[3];
    fs->yv[3] = fs->yv[4];
    fs->yv[4] = fs->yv[5];
    fs->yv[5] = fs->yv[6];

    /*  Current output value depend on the sum of previous inputs and previous
       multiplied by there respective coefficients */

    fs->yv[6] = (fs->c_coef[0] * fs->xv[0]) + (fs->c_coef[1] * fs->xv[1]) +
	(fs->c_coef[2] * fs->xv[2]) + (fs->c_coef[3] * fs->xv[3]) +
	(fs->c_coef[4] * fs->xv[4]) + (fs->c_coef[5] * fs->xv[5]) +
	(fs->c_coef[6] * fs->xv[6]) +
	(fs->d_coef[0] * fs->yv[0]) + (fs->d_coef[1] * fs->yv[1]) +
	(fs->d_coef[2] * fs->yv[2]) + (fs->d_coef[3] * fs->yv[3]) +
	(fs->d_coef[4] * fs->yv[4]) + (fs->d_coef[5] * fs->yv[5]);
    return (int) fs->yv[6];
}


/**@brief FSK demodulation.
 *
 * For FSK demodulation using recursive filter, the waveform is passed through
 * Mark and Space filter to create the respective envelope. Based on the filter
 * values, decision is made whether it's Mark or it's Space. But the values 
 * generated by this filter can fade, so we use a low pass filter to 
 * differentiate between the two frequencies.
 *
 * @param fskd pointer to the data struct containing FSK parameters
 * @param retval pointer to contain the demodulated value
 * @param x Current value of the sample	
 */
static inline int idemodulator(fsk_data * fskd, int *retval, int x)
{
    int is, im, id;
    int ilin2;
    double scale;

    is = filter(&fskd->space_filter, x);        // Calculating Space filter value
    im = filter(&fskd->mark_filter, x);	        // Calculating Mark filter value

    scale = SCALE;                              // Scale is used to reduce the value
                                                // so the demodulated value does not 
                                                // exceed single digit.
    ilin2 = ((is * is) - (im * im)) / scale;    // Calculating RMS value (squaring)

    id = filter(&fskd->demod_filter, ilin2);    // The difference between Mark and 
                                                // Space is passed through a low pass
                                                // filter.
#ifdef VERBOSE
    fprintf(stderr, "IGET_SAMPLE: %8d, \tSpace: %8d, \tMark: %8d, \tIlin: %8d, \tID: %8d\n",
        x, is, im, ilin2, id);
#endif

#ifdef DEBUG
    if (gnu) {
	
	if (gnu_count < PLOT_NUM) {
	    mark[gnu_count] = im;
	    space[gnu_count] = is;
	    sample_value[gnu_count] = x;
	    diff[gnu_count] = ilin2;
	    lp[gnu_count++] = id;
	}
    }
#endif

    *retval = id;
    return 0;
}

/**@brief Initialize the FSK data
 *
 * Initialize all the parameters used by the filter and demodulator
 * functions to decode the CID message. The parameters are already calculated
 * in filter_coefficient.h file.
 *	
 * @param fskd pointer to fsk_data struct
 */
int fskmodem_init(fsk_data * fskd)
{
    int i;

    for (i = 0; i <= NZEROS_POLES; i++) {

	fskd->mark_filter.xv[i] = zeros[i];
	fskd->mark_filter.yv[i] = zeros[i];
	fskd->mark_filter.c_coef[i] = c_coef_3rd_bp[i];

	fskd->space_filter.xv[i] = zeros[i];
	fskd->space_filter.yv[i] = zeros[i];
	fskd->space_filter.c_coef[i] = c_coef_3rd_bp[i];

	fskd->demod_filter.xv[i] = zeros[i];
	fskd->demod_filter.yv[i] = zeros[i];
	fskd->demod_filter.c_coef[i] = c_coef_6th_lp[i];
	fskd->demod_filter.d_coef[i] = d_coef_lp_1700hz[i];
	fskd->demod_filter.gain = gain_lp_1700hz;

	// Based on FSK standard used for CallerID, different coefficients 
	// can be used form "filter_coefficient.h"
	if (fskd->fsk_std == 0) {
	    fskd->mark_filter.d_coef[i] = d_coef_1200hz[i];
	    fskd->mark_filter.gain = gain_1200hz;

	    fskd->space_filter.d_coef[i] = d_coef_2200hz[i];
	    fskd->space_filter.gain = gain_2200hz;
	} else {
	    fskd->mark_filter.d_coef[i] = d_coef_1300hz[i];
	    fskd->mark_filter.gain = gain_1300hz;

	    fskd->space_filter.d_coef[i] = d_coef_2100hz[i];
	    fskd->space_filter.gain = gain_2100hz;
	}
    }
    return 0;
}

/**@brief Get a single bit of FSK signal.
 *	
 * This function implements a DPLL to synchronize with the bits and 
 * decode a single FSK bit data. It looks for the transition between 0s 
 * and 1s and adjust the PLL value.
 *
 * @param fskd pointer to data struct containing FSK parameters
 * @param buffer pointer to buffer containing samples
 * @param len pointer to current number of samples in the buffer
 *
 * @retval 0x80 if the FSK bit is 1 
 * @retval 0x00 if the FSK bit is 0.
 * @retval -1 if the number fo samples are not sufficient for a bit
 */
static int get_bit_raw(fsk_data * fskd, short *buffer, int *len)
{
    int f;
    int current_sample;
    int ix;
    static int roundoff = 0;


    if (*len < (fskd->ispb + 2))                        // Minimum samples required
	return -1;

#ifdef VERBOSE
    fprintf(stderr, "\n\n");
#endif

    for (f = 0;;) {                                     // DPLL loop
        current_sample = iget_sample(&buffer, len);
        idemodulator(fskd, &ix, current_sample);        // Check cuurent sample

                                                        // Checks for the transition 
        if ((ix >= 0 && fskd->xi0 < 0) || (ix < 0 && fskd->xi0 >= 0)) {
            if (!f) {
	        if (fskd->icont < (fskd->pllispb2)) {
	            fskd->icont += fskd->pllids;        // Increases DPLL counter       
	        } else {
	            fskd->icont -= fskd->pllids;        // Decreases DPLL counter
	        }
	        f = 1;                                  // DPLL is adjusted just once
	        roundoff = 0;                           // no need when there's transition
            }
        }
        fskd->xi0 = ix;
        fskd->icont += 32;

        if (fskd->icont > fskd->pllispb) {              // Exit the currnt DPLL loop    
            fskd->icont -= fskd->pllispb;               // Reset the counter

            /*      Sampling of the bit is done with an integer value of ispb. But the
               result of sample_rate/ baud_rate is a float value. So to keep the
               PLL synced when there is no transition for long time, we use this
               roundoff when the ispb is very less. */

            /*if(f == 0)    roundoff++;
               if(roundoff == fskd->pll_round_off){
               current_sample = iget_sample(&buffer, len);  
               idemodulator(fskd, &ix, current_sample) ;
               roundoff = 0;
               fprintf(stderr, "here jjjjjjj\n");
               } */
            break;
        }
    }

#ifdef VERBOSE                                  //Presentation
    fprintf(stderr, "\n[%s], The bit is", (fskd->state == 2) ? "CHANNEL SEIZURE" : 
                                ((fskd->state == 3) ? "MARK SIGNAL" : "DATA FRAME"));
#endif
    if (count % 30 == 0)
	fprintf(stderr, "\n");                  //Presentation
    f = (ix < 0) ? 0x80 : 0;                    // differentiate Mark and Space
                                                // based on demodulator value 
    fprintf(stderr, "\t%d", (f ? 1 : 0));       // Print 1 or 0
    return f;
}

/**@brief Detecting channel seizure signal.
 *
 * The Caller ID message starts with a Channel seizure signal which 
 * consists 300 bits containing alternate 1s and 0s.
 * Checking if we detected the channel seizure signal properly.
 *
 * @param fskd Address of pointer to FSK data structure
 * @param buffer Address of pointer to current sample
 * @param len Address of pointer containing pointer of length
 *
 * @return 0 if successful else -1 if error
 */
static int get_channel_seizure(fsk_data ** fskd, short **buffer, int **len)
{
    static int one_zero = 1;
    int olen;
    int res;

    while ((**len > 0)) {
	olen = **len;
	res = get_bit_raw(*fskd, *buffer, *len);        //Getting the current data bit

	if (res == -1)
	    return 0;                                   // Number of samples is less than 40
	else if (res)
	    one_zero++;	                                // increamenting for mark signal
	else
	    one_zero--;                                 // incrementing for space

	*buffer += (olen - **len);
	if ((count > 295) && (one_zero > 1))            // We have already detected the starting 
	    return count;                               // bit, So count is 298. sometime there are
	                                                // more than 300 alternate 1s and 0s. So 
	                                                // we wait untill we get 2 consecutive 1's.

	else if (one_zero < 0 || one_zero > 1) {        // to check if 0s and 1s are alternate
	    fprintf(stderr,
		    "\n\nfailed to detect alternate 1s and 0s\n\n");
	    count = 0;
	    one_zero = 1;

#ifdef DEBUG
		gnu = 0;
		gnu_count = 0;
#endif
	    return -1;
	}
	count++;
    }

    return 0;
}

/**@brief Detecting Mark signal.
 *
 * After the channel seizure, there is a sequence of 180 Mark signals. 
 * The purpose of the Channel Seizure Signal and the Mark Signal is to 
 * prepare the data receiver in the Customer Premise Equipment (CPE) 
 * for the reception of the actual CID message
 *
 * @param fskd Address of pointer to FSK data structure
 * @param buffer Address of pointer to current sample
 * @param len Address of pointer containing pointer of length
 *
 * @return 0 if successful else -1 if error
 */
static int get_mark_signal(fsk_data ** fskd, short **buffer, int **len)
{
    int olen;
    int res;

    while (**len > 0) {
	olen = **len;
	res = get_bit_raw(*fskd, *buffer, *len);        //Getting the current data bit

	if (res == -1)
	    return 0;                                   // Number of samples is less than 40
	else if (res) {
	    count++;                                    // increamenting for mark signal
	    *buffer += (olen - **len);
	} else if ((count > 160) && (res == 0)) {       // The number of consecutive mark signals
	    (**len) = olen;                             // can vary. So we wait untill we get the
	    return count;                               // start bit of the data frame. But we decrement
	}                                               // so that we can start again from the start bit.

	else {
	    fprintf(stderr, "\n\nfailed to detect Mark signal\n\n");
	    count = 0;
	    return -1;
	}
    }
    return 0;
}

/**@brief Get the data frame.
 *
 * Data bytes starts after the Mark signal. 
 * The message consists of a sequence of 10-bit frames. A start bit(0),
 * 8 bits of information(LSB to MSB) and then a stop bit(1).
 *
 * @param fskd Address of pointer to FSK data structure
 * @param buffer Address of pointer to current sample
 * @param len Address of pointer containing pointer of length
 *
 * @return 0 if successful else -1 if error
 */
static int get_data_frame(fsk_data ** fskd, short **buffer, int **len)
{
    int a;
    int i, j, n1;
    int olen = **len;

    if (get_bit_raw(*fskd, *buffer, *len) == 0) {       //Get the start bit of the frame 

	*buffer += (olen - **len);
	j = (*fskd)->nbit;

	for (a = n1 = 0; j; j--) {                      // Get the 8 data bit of the frame 
	    olen = **len;
	    i = get_bit_raw(*fskd, *buffer, *len);
	    *buffer += (olen - **len);

	    if (i == -1)
		return 0;                               // Number of samples is less than 40
	    a >>= 1;                                    // Shifting the bit because bits are transmitted
	    a |= i;                                     // from LSB to MSB
	}
    } else {
	fprintf(stderr, "\n\n\nStart bit of Data Bytes not Found\n");
	return -1;
    }


    for (i = 0; i < (*fskd)->instop; i++) {             // Get the stop bit of the frame
	olen = **len;                                   // there can be two stop bits
	if (!get_bit_raw(*fskd, *buffer, *len)) {
	    fprintf(stderr, "\n\n\nStop bit of Data Bytes not Found\n");
	    return -1;
	}
	*buffer += (olen - **len);
    }

    return a;
}



/**@brief Retrieve a serial byte into outbyte.
 *
 * Buffer is a pointer into a series of
 * shorts and len records the number of bytes in the buffer.  len will be
 * overwritten with the number of bytes left that were not consumed.
 *
 * @return return value is as follows:
 * @arg 0: Still looking for something...
 * @arg 1: An output byte was received and stored in outbyte
 * @arg -1: An error occured in the transmission 
 */
int fsk_serial(fsk_data * fskd, short *buffer, int *len, int *outbyte)
{
    int i;
    int samples = 0;
    int res;
    int current_sample;


    /* Pick up where we left off */
    switch (fskd->state) {

    case STATE_SEARCH_STARTBIT:

	/* Detecting the start of space in the channel seizure. The bandpass value 
	   is high when there is some rise in the amplitude, otherwise its 0. */

	fprintf(stderr, "\nSearching for the start bit...\n");
	while (*len > 0) {
	    current_sample = iget_sample(&buffer, len);
	    idemodulator(fskd, &fskd->xi2, current_sample);
	    samples++;

	    // Threshold to detect the start of the FSK data
	    if (fskd->xi2 < 0) {
		fskd->state = STATE_SEARCH_STARTBIT2;
		break;
	    }
	}
	break;

    case STATE_SEARCH_STARTBIT2:

	/* After Detecting the rise in the waveform, we get to the one third point 
	   of the bit, i.e. reaching 0.33 of the bit. It can be changed according to
	   Sampling frequency ad the baud rate */

	fprintf(stderr, "\nGetting to the center of the bit...\n");
	i = fskd->ispb / 2;
	for (; i > 0; i--) {
	    current_sample = iget_sample(&buffer, len);
	    idemodulator(fskd, &fskd->xi1, current_sample);
	    samples++;
	}
	fskd->state = STATE_CHANNEL_SEIZURE;
	fprintf(stderr, "\nEntering channel seizure...\n\n");
	break;

    case STATE_CHANNEL_SEIZURE:

	/* Detecting Channel seizure */
#ifdef DEBUG
	gnu = 1;
#endif

	res = get_channel_seizure(&fskd, &buffer, &len);
	if (res == -1) {
	    fskd->state = STATE_SEARCH_STARTBIT;
	    break;
	} else if (res) {
	    count = 0;
	    fprintf(stderr,"\n\nChannel seizure detected with %d alternate 1s and 0s.\n", res);
	    fprintf(stderr, "\nDetecting Mark signal... \n");
	    fskd->state = STATE_MARK_SIGNAL;
	}
	break;

    case STATE_MARK_SIGNAL:

#ifdef DEBUG
	if (gnu) {
	    gnuplot_ctrl *g1 = gnuplot_init();
	    gnuplot_ctrl *g2 = gnuplot_init();
	    gnuplot_ctrl *g3 = gnuplot_init();
	    gnuplot_ctrl *g4 = gnuplot_init();
	    gnuplot_ctrl *g5 = gnuplot_init();

	    gnuplot_cmd(g1, "set terminal png");
	    gnuplot_cmd(g1, "set output \"./Sample_value.png\"");
	    gnuplot_setstyle(g1, "lines");
	    gnuplot_plot_x(g1, sample_value, PLOT_NUM, " Caller-ID samples");

	    gnuplot_cmd(g2, "set terminal png");
	    gnuplot_cmd(g2, "set output \"./Mark_value.png\"");
	    gnuplot_setstyle(g2, "lines");
	    gnuplot_plot_x(g2, mark, PLOT_NUM, " Mark values");

	    gnuplot_cmd(g3, "set terminal png");
	    gnuplot_cmd(g3, "set output \"./Space_value.png\"");
	    gnuplot_setstyle(g3, "lines");
	    gnuplot_plot_x(g3, space, PLOT_NUM, " space values");

	    gnuplot_cmd(g4, "set terminal png");
	    gnuplot_cmd(g4, "set output \"./ilin2.png\"");
	    gnuplot_setstyle(g4, "lines");
	    gnuplot_plot_x(g4, diff, PLOT_NUM, " space values");

	    gnuplot_cmd(g5, "set terminal png");
	    gnuplot_cmd(g5, "set output \"./lp.png\"");
	    gnuplot_setstyle(g5, "lines");
	    gnuplot_plot_x(g5, lp, PLOT_NUM, " space values");

	    gnuplot_close(g1);
	    gnuplot_close(g2);
	    gnuplot_close(g3);
	    gnuplot_close(g4);
	    gnuplot_close(g5);
	    gnu = 0;
	}
#endif    

	/* Detecting Mark signal */

	res = get_mark_signal(&fskd, &buffer, &len);
	if (res) {
	    fprintf(stderr, "\n\nMark signal detected with %d consecutive 1s\n", res);
	    fprintf(stderr, "\nGetting Caller ID message data bytes...\n");
	    fprintf(stderr, "\nSTART\t\t\t\t8 data bits\t\t\tSTOP\n");
	    fskd->state = STATE_GET_DATA_FRAME;
	}
	break;

    case STATE_GET_DATA_FRAME:

	/*For demodulating a byte we require 10 or 11 bits. 12 for safer side */

	if (*len > (fskd->ispb * 12)) {
	    *outbyte = get_data_frame(&fskd, &buffer, &len);
	    return 1;
	}
	break;
    default:
	fprintf(stderr, "\n\tInvalid State in FSK demodulation\n");
	break;
    }

    return 0;
}
